{"version":3,"file":"static/js/4591.5e37bddf.chunk.js","mappings":"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","sources":["../node_modules/viem/errors/ccip.ts","../node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n        name: 'OffchainLookupError',\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n        name: 'OffchainLookupResponseMalformedError',\n      },\n    )\n  }\n}\n\n/** @internal */\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n        name: 'OffchainLookupSenderMismatchError',\n      },\n    )\n  }\n}\n","import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport {\n  localBatchGatewayRequest,\n  localBatchGatewayUrl,\n} from './ens/localBatchGatewayRequest.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = urls.includes(localBatchGatewayUrl)\n      ? await localBatchGatewayRequest({\n          data: callData,\n          ccipRequest: ccipRequest_,\n        })\n      : await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n    const headers: HeadersInit =\n      method === 'POST' ? { 'Content-Type': 'application/json' } : {}\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender.toLowerCase()).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          headers,\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"names":["OffchainLookupError","callbackSelector","cause","data","extraData","sender","urls","shortMessage","metaMessages","length","map","url","getUrl","flat","name","BaseError","OffchainLookupResponseMalformedError","result","stringify","OffchainLookupSenderMismatchError","to","offchainLookupSignature","offchainLookupAbiItem","type","inputs","offchainLookup","client","blockNumber","blockTag","decodeErrorResult","abi","args","callData","ccipRead","ccipRequest_","request","ccipRequest","isAddressEqual","includes","localBatchGatewayUrl","localBatchGatewayRequest","call","concat","encodeAbiParameters","data_","error","Error","i","method","body","undefined","headers","fetch","replace","toLowerCase","JSON","response","get","startsWith","json","text","ok","HttpRequestError","details","statusText","status","isHex","message"],"sourceRoot":""}